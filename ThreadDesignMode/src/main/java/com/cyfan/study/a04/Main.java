package com.cyfan.study.a04;


/**
 * 4、balking模式（回避模式） 不满足条件直接return
 *      核心代码：
 *         synchronized(lock){
 *             while(条件){  // 条件不满足
 *               return;  //当前线程直接结束，不执行后续逻辑
 *              }
 *              //后续很长的逻辑
 *         }
 *
 * a.特点：多个线程之间通过一个状态进行判断，拿到锁的线程，判断状态是否满足条件，满足则执行后续业务逻辑，不满足则直接返回，代表已经被其他线程执行过了
 *      如果现在不适合执行这个操作，或者没必要执行这个操作，就停止处理直接返回。
 *      有多个（起码2个）线程，在某一个线程正准备做某件事的时候，然后突然呢，另外一个线程抢先做了，那么这个线程就不执行这个动作了
 *      case:
 *          医院挂号，多个病人找医生挂号，医生录入信息后，可手动刷新，让挂号信息展示（大屏展示病人到几号诊室），也可以30秒后自动刷新，让挂号信息展示。
 *          若未到30秒，医生进行了手动刷新，那么定时线程就可以在下一个刷新的时候停止了。（2个线程，手动，定时线程）
 * b.比较 GuardedSuspension 和 Balking 模式设计模式
 *   角色分析：（相同点）
 *      1.受保护对象（公共资源）
 *       GS模式：queue
 *       Balking:电子屏
 *       总结：只有公共资源里面才会有 synchronized 关键字，而在线程类里面不会出现 synchronized 关键字。
 *      2.受保护的方法（公共资源里，被多线程访问的方法）
 *       synchronized关键字修饰的方法或代码块所在的方法
 *      3.受保护对象的状态（公共资源的而状态）
 *       状态一般在条件里面，多线程的执行一定遵循共有资源状态的变化而采取不同的执行策略。
 *   深层次细节比较：（不同点）
 *      GS模式：需要进行等待和唤醒操作
 *      Balking模式：不需要进行等待和唤醒操作，而是判断状态不对，就立马返回。
 *
 * c.Balking模式使用场景
 *  1.不需要再执行了（不做了）。有线程执行过，其他线程就不执行了，什么都不做，直接返回。提交了程序的性能
 *  2.不需要等待守护条件成立时，返回。那这种模式调高了程序的响应。
 *  3.守护条件仅仅在第一次成立时（ 服务器初始化）
 */
public class Main {
}
